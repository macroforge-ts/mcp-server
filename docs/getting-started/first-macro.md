# Your First Macro

*Let's create a class that uses Macroforge's derive macros to automatically generate useful methods.*

## Creating a Class with Derive Macros

Start by creating a simple `User` class. We'll use the `@derive` decorator to automatically generate methods.

`user.ts`
```typescript
import { Debug, Clone, Eq } from "macroforge";

/** @derive(Debug, Clone, Eq) */
export class User {
  name: string;
  age: number;
  email: string;

  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
}
```

## What Gets Generated

After macro expansion, your class will have these methods:

`user.ts (expanded)`
```typescript
export class User {
  name: string;
  age: number;
  email: string;

  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }

  // Generated by Debug
  toString(): string {
    return \`User { name: \${this.name}, age: \${this.age}, email: \${this.email} }\`;
  }

  // Generated by Clone
  clone(): User {
    return new User(this.name, this.age, this.email);
  }

  // Generated by Eq
  equals(other: User): boolean {
    return this.name === other.name
      && this.age === other.age
      && this.email === other.email;
  }
}
```

## Using the Generated Methods

```typescript
const user = new User("Alice", 30, "alice@example.com");

// Debug: toString()
console.log(user.toString());
// Output: User { name: Alice, age: 30, email: alice@example.com }

// Clone: clone()
const copy = user.clone();
console.log(copy.name); // "Alice"

// Eq: equals()
console.log(user.equals(copy)); // true

const different = new User("Bob", 25, "bob@example.com");
console.log(user.equals(different)); // false
```

## Customizing Behavior

You can customize how macros work using field-level decorators. For example, with the Debug macro:

```typescript
/** @derive(Debug) */
export class User {
  /** @debug({ rename: "userId" }) */
  id: number;

  name: string;

  /** @debug({ skip: true }) */
  password: string;

  constructor(id: number, name: string, password: string) {
    this.id = id;
    this.name = name;
    this.password = password;
  }
}

const user = new User(42, "Alice", "secret123");
console.log(user.toString());
// Output: User { userId: 42, name: Alice }
// Note: 'id' is renamed to 'userId', 'password' is skipped
```

>
> Field-level decorators let you control exactly how each field is handled by the macro.

## Next Steps

- [Learn how macros work under the hood]({base}/docs/concepts)

- [Explore all Debug options]({base}/docs/builtin-macros/debug)

- [Create your own custom macros]({base}/docs/custom-macros)